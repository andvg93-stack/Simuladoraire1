<!DOCTYPE html>
<html lang="es">
<head>
<meta charset="UTF-8">
<title>Simulador Ambiental Isométrico</title>
<style>
  body { margin: 0; overflow: hidden; background: #FFE082; font-family: sans-serif; }

  /* Estilos para el panel de control */
  #ui-panel {
    position: absolute;
    top: 20px;
    left: 20px;
    background: rgba(255, 255, 255, 0.9);
    padding: 15px;
    border-radius: 10px;
    box-shadow: 0 4px 10px rgba(0,0,0,0.2);
    width: 250px;
    z-index: 100;
  }
  .control-group { margin-bottom: 15px; }
  label { display: block; font-size: 12px; font-weight: bold; margin-bottom: 5px; color: #333; }
  input[type=range] { width: 100%; cursor: pointer; }
  .value-display { float: right; color: #666; }

  #data-panel-wrapper {
    position: absolute;
    top: 20px;
    right: 20px;
    width: 260px;
    height: 260px;
    display: flex;
    align-items: center;
    justify-content: center;
    z-index: 90;
    pointer-events: none;
  }

  #data-panel-background {
    position: absolute;
    width: 280px;
    height: 280px;
    opacity: 0.55;
    transform: translate(-10px, 10px);
    border-radius: 18px;
    background: radial-gradient(circle at top, rgba(0, 255, 204, 0.25), rgba(0, 80, 60, 0.6));
    border: 2px solid rgba(0, 255, 204, 0.4);
    box-shadow: 0 0 25px rgba(0, 255, 204, 0.35);
  }

  #data-panel {
    position: relative;
    background: rgba(0, 0, 0, 0.8);
    color: #00ff00;
    padding: 15px;
    border-radius: 8px;
    font-family: 'Courier New', monospace;
    width: 220px;
    font-size: 13px;
    z-index: 100;
    border: 1px solid #444;
    pointer-events: auto;
  }

  #routes-panel {
    position: absolute;
    bottom: 20px;
    left: 20px;
    width: 320px;
    background: rgba(255, 255, 255, 0.92);
    padding: 12px;
    border-radius: 10px;
    box-shadow: 0 4px 10px rgba(0,0,0,0.2);
    z-index: 100;
  }

  #routes-panel.hidden {
    display: none;
  }

  #routes-panel h4 {
    margin: 0 0 8px 0;
  }

  #routes-canvas {
    width: 100%;
    height: 240px;
    border: 1px solid #c2c2c2;
    border-radius: 6px;
    background: #f8f8f8;
    display: block;
  }

  #routes-controls {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 8px;
    margin-top: 8px;
  }

  #routes-controls button,
  #routes-controls input[type="file"] {
    font-size: 12px;
  }

  #routes-select {
    width: 100%;
    margin-top: 6px;
  }

  .hint {
    font-size: 11px;
    color: #555;
    margin-top: 6px;
  }
</style>
</head>
<body>

<div id="ui-panel">
  <h3 style="margin-top:0">Configuración Ambiental</h3>

  <div class="control-group">
    <label>Coches (Contaminación) <span id="val-coches" class="value-display">20</span></label>
    <input type="range" id="slider-coches" min="0" max="60" value="20">
  </div>

  <div class="control-group">
    <label>Árboles (Albedo) <span id="val-arboles" class="value-display">80</span></label>
    <input type="range" id="slider-arboles" min="0" max="200" value="80">
  </div>

  <div class="control-group">
    <label>Edificios (Densidad) <span id="val-edificios" class="value-display">75%</span></label>
    <input type="range" id="slider-edificios" min="0" max="100" value="75">
  </div>
</div>

<div id="data-panel-wrapper">
  <div id="data-panel-background" aria-hidden="true"></div>
  <div id="data-panel">
    <h4 style="margin: 0 0 10px 0; color: #fff; text-align: center; border-bottom: 1px solid #444;">ESTACIÓN MONITOREO</h4>

    <div>PM2.5: <span id="val-pm25">--</span> µg/m³</div>
    <div>PM10: <span id="val-pm10">--</span> µg/m³</div>
    <div>CO₂: <span id="val-co2">--</span> ppm</div>
    <div>Temp: <span id="val-temp">--</span> °C</div>
    <div>O₃: <span id="val-o3">--</span> ppb</div>
    <div>NOx: <span id="val-nox">--</span> ppb</div>
    <div>COV: <span id="val-cov">--</span> µg/m³</div>
  </div>
</div>

<div id="routes-panel">
  <h4>Editor de rutas (2D)</h4>
  <canvas id="routes-canvas" width="300" height="240"></canvas>
  <select id="routes-select"></select>
  <div id="routes-controls">
    <button id="btn-nueva-ruta" type="button">Nueva ruta</button>
    <button id="btn-limpiar-ruta" type="button">Limpiar ruta</button>
    <button id="btn-descargar" type="button">Descargar JSON</button>
    <input id="input-cargar" type="file" accept="application/json">
  </div>
  <div class="hint">Click para agregar puntos. Arrastra para mover. Shift+click elimina punto.</div>
</div>

<script type="importmap">
{
  "imports": {
    "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
    "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
  }
}
</script>

<script type="module">
import * as THREE from 'three';
import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
import { RoundedBoxGeometry } from 'three/addons/geometries/RoundedBoxGeometry.js';

const ROUTES_URL = './routes.json';
const SHOW_ROUTE_EDITOR = true;
const DEFAULT_ROUTES_DATA = {
  grid: {
    cols: 15,
    rows: 15,
    cellSize: 5,
    origin: { x: -35, z: -35 }
  },
  routes: [
    {
      id: 1,
      name: 'Ruta A',
      color: '#ff6f00',
      points: [
        { x: 0, z: 13 },
        { x: 10, z: 13 },
        { x: 10, z: 0 }
      ]
    },
    {
      id: 2,
      name: 'Ruta B',
      color: '#8e24aa',
      points: [
        { x: 13, z: 13 },
        { x: 0, z: 13 }
      ]
    },
    {
      id: 3,
      name: 'Ruta C',
      color: '#1e88e5',
      points: [
        { x: 11, z: 0 },
        { x: 11, z: 13 },
        { x: 0, z: 13 }
      ]
    },
    {
      id: 4,
      name: 'Ruta D',
      color: '#43a047',
      points: [
        { x: 13, z: 12 },
        { x: 11, z: 12 },
        { x: 11, z: 5 }
      ]
    }
  ]
};

let rutasData = structuredClone(DEFAULT_ROUTES_DATA);

function actualizarParametrosFisicoquimicos() {
  const nCoches = parseInt(document.getElementById('slider-coches').value);
  const nArboles = parseInt(document.getElementById('slider-arboles').value);
  const densEdificios = parseInt(document.getElementById('slider-edificios').value);

  const pm25 = Math.max(5, (nCoches * 1.2) - (nArboles * 0.05)).toFixed(1);
  const pm10 = Math.max(10, (nCoches * 2.1) - (nArboles * 0.1)).toFixed(1);
  const co2 = Math.floor(410 + (nCoches * 3.5) - (nArboles * 0.4));
  const temp = (22 + (densEdificios * 0.08) + (nCoches * 0.05) - (nArboles * 0.02)).toFixed(1);
  const o3 = Math.max(15, (nCoches * 0.8) + (temp * 0.2) - (nArboles * 0.03)).toFixed(1);
  const nox = Math.floor(nCoches * 1.8);
  const cov = ((nCoches * 0.5) + (densEdificios * 0.2)).toFixed(1);

  document.getElementById('val-pm25').innerText = pm25;
  document.getElementById('val-pm10').innerText = pm10;
  document.getElementById('val-co2').innerText = co2;
  document.getElementById('val-temp').innerText = temp;
  document.getElementById('val-o3').innerText = o3;
  document.getElementById('val-nox').innerText = nox;
  document.getElementById('val-cov').innerText = cov;
}

const scene = new THREE.Scene();
scene.background = new THREE.Color("#FFE082");
scene.fog = new THREE.FogExp2(0xefd1b5, 0.002);

const aspect = window.innerWidth / window.innerHeight;
const d = 55;
const camera = new THREE.OrthographicCamera(-d * aspect, d * aspect, d, -d, 0.1, 500);
camera.position.set(65, 65, 65);
camera.lookAt(0, 0, 0);

const renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.shadowMap.enabled = true;
renderer.toneMapping = THREE.ACESFilmicToneMapping;
document.body.appendChild(renderer.domElement);

const controls = new OrbitControls(camera, renderer.domElement);
controls.enableDamping = true;

let listaEdificios = [];
let listaArboles = [];
let edificiosOcupados = [];
let MAX_COCHES = 50;

const buildingPalette = [
  0x90caf9,
  0x64b5f6,
  0xa5d6a7,
  0xffcc80,
  0xce93d8,
  0xb0bec5,
  0xffab91,
  0x80cbc4,
  0xf48fb1
];
const sun = new THREE.DirectionalLight(0xfff4e0, 1.2);
sun.position.set(50, 80, 30);
sun.castShadow = true;
scene.add(sun, new THREE.AmbientLight(0xb3d9ff, 0.5), new THREE.HemisphereLight(0x87ceeb, 0xf0e6d2, 0.4));
const size = 80;
sun.shadow.camera.left = -size;
sun.shadow.camera.right = size;
sun.shadow.camera.top = size;
sun.shadow.camera.bottom = -size;

sun.shadow.camera.near = 1;
sun.shadow.camera.far = 200;

sun.shadow.mapSize.width = 4096;
sun.shadow.mapSize.height = 4096;

const base = new THREE.Mesh(new RoundedBoxGeometry(75, 2, 75, 6, 2), new THREE.MeshStandardMaterial({ color: 0xf5f5f5 }));
base.receiveShadow = true;
scene.add(base);

const agua = new THREE.Mesh(new THREE.BoxGeometry(95, 4, 95), new THREE.MeshStandardMaterial({ color: 0x26c6da, transparent: true, opacity: 0.8 }));
agua.position.y = -3.5;
scene.add(agua);

function crearMaterialFachada(color) {
  const c = document.createElement("canvas");
  c.width = c.height = 128;
  const ctx = c.getContext("2d");
  ctx.fillStyle = `#${color.toString(16).padStart(6, '0')}`;
  ctx.fillRect(0, 0, 128, 128);
  ctx.fillStyle = "rgba(255,255,255,0.35)";
  for (let y = 8; y < 128; y += 18) {
    for (let x = 8; x < 128; x += 18) {
      ctx.fillRect(x, y, 8, 10);
    }
  }
  return new THREE.MeshStandardMaterial({ map: new THREE.CanvasTexture(c) });
}

function limpiarGrupo(lista) {
  lista.forEach(obj => scene.remove(obj));
  return [];
}

const zonasProhibidas = [
  { x: 0, z: 30, w: 70, d: 8 },
  { x: 25, z: -10, w: 15, d: 8 },
  { x: 20, z: 0, w: 8, d: 70 }
];

function estaEnZonaProhibida(x, z, w, d) {
  return zonasProhibidas.some(zona => !(x + w / 2 < zona.x - zona.w / 2 || x - w / 2 > zona.x + zona.w / 2 || z + d / 2 < zona.z - zona.d / 2 || z - d / 2 > zona.z + zona.d / 2));
}

function crearEdificio(x, z, w, d, h, color) {
  const g = new THREE.Group();
  const cuerpo = new THREE.Mesh(new THREE.BoxGeometry(w, h, d), crearMaterialFachada(color));
  cuerpo.castShadow = cuerpo.receiveShadow = true;
  g.add(cuerpo);

  const tipo = THREE.MathUtils.randInt(0, 3);
  if (tipo === 0) {
    const techo = new THREE.Mesh(new THREE.BoxGeometry(w * 0.9, h * 0.12, d * 0.9), new THREE.MeshStandardMaterial({ color: 0x455a64 }));
    techo.position.y = h / 2 + (h * 0.06);
    techo.castShadow = true;
    g.add(techo);
  } else if (tipo === 1) {
    const corona = new THREE.Mesh(new THREE.BoxGeometry(w * 0.6, h * 0.25, d * 0.6), new THREE.MeshStandardMaterial({ color: 0x90a4ae }));
    corona.position.y = h / 2 + (h * 0.12);
    corona.castShadow = true;
    g.add(corona);
  } else if (tipo === 2) {
    const antena = new THREE.Mesh(new THREE.CylinderGeometry(0.2, 0.2, h * 0.4), new THREE.MeshStandardMaterial({ color: 0x78909c }));
    antena.position.y = h / 2 + (h * 0.2);
    antena.castShadow = true;
    g.add(antena);
  }

  g.position.set(x, h / 2 + 1, z);
  return g;
}

function actualizarEdificios(densidad) {
  listaEdificios = limpiarGrupo(listaEdificios);
  edificiosOcupados = [];

  for (let x = -30; x <= 30; x += 10) {
    for (let z = -30; z <= 30; z += 10) {
      if (Math.random() < densidad / 100) {
        const w = THREE.MathUtils.randInt(4, 8);
        const d = THREE.MathUtils.randInt(4, 8);
        if (estaEnZonaProhibida(x, z, w, d)) continue;

        const h = (Math.hypot(x, z) < 15) ? THREE.MathUtils.randInt(30, 65) : THREE.MathUtils.randInt(10, 30);
        const color = buildingPalette[Math.floor(Math.random() * buildingPalette.length)];

        const g = crearEdificio(x, z, w, d, h, color);
        scene.add(g);
        listaEdificios.push(g);
        edificiosOcupados.push({ x, z, w: w + 2, d: d + 2 });
      }
    }
  }
}

const treeStyles = [
  {
    crear() {
      const copa = new THREE.Mesh(new THREE.SphereGeometry(1.8, 8, 8), new THREE.MeshStandardMaterial({ color: 0x43a047 }));
      copa.position.y = 3.2;
      copa.castShadow = true;
      const tronco = new THREE.Mesh(new THREE.CylinderGeometry(0.2, 0.35, 2.2), new THREE.MeshStandardMaterial({ color: 0x6d4c41 }));
      tronco.position.y = 1.1;
      return [tronco, copa];
    }
  },
  {
    crear() {
      const copa = new THREE.Mesh(new THREE.ConeGeometry(1.6, 3.5, 10), new THREE.MeshStandardMaterial({ color: 0x2e7d32 }));
      copa.position.y = 3.4;
      copa.castShadow = true;
      const tronco = new THREE.Mesh(new THREE.CylinderGeometry(0.22, 0.4, 2.4), new THREE.MeshStandardMaterial({ color: 0x5d4037 }));
      tronco.position.y = 1.1;
      return [tronco, copa];
    }
  },
  {
    crear() {
      const copa1 = new THREE.Mesh(new THREE.SphereGeometry(1.2, 8, 8), new THREE.MeshStandardMaterial({ color: 0x66bb6a }));
      const copa2 = new THREE.Mesh(new THREE.SphereGeometry(1.1, 8, 8), new THREE.MeshStandardMaterial({ color: 0x4caf50 }));
      copa1.position.set(-0.4, 3, 0.2);
      copa2.position.set(0.5, 3.4, -0.2);
      copa1.castShadow = copa2.castShadow = true;
      const tronco = new THREE.Mesh(new THREE.CylinderGeometry(0.2, 0.35, 2.1), new THREE.MeshStandardMaterial({ color: 0x6d4c41 }));
      tronco.position.y = 1;
      return [tronco, copa1, copa2];
    }
  },
  {
    crear() {
      const copa = new THREE.Mesh(new THREE.DodecahedronGeometry(1.6), new THREE.MeshStandardMaterial({ color: 0x388e3c }));
      copa.position.y = 3.1;
      copa.castShadow = true;
      const tronco = new THREE.Mesh(new THREE.CylinderGeometry(0.18, 0.28, 2), new THREE.MeshStandardMaterial({ color: 0x4e342e }));
      tronco.position.y = 1;
      return [tronco, copa];
    }
  }
];

function actualizarArboles(cantidad) {
  listaArboles = limpiarGrupo(listaArboles);
  let creados = 0;
  let intentos = 0;

  while (creados < cantidad && intentos < 500) {
    const x = THREE.MathUtils.randFloat(-32, 32);
    const z = THREE.MathUtils.randFloat(-32, 32);
    const TAM = 3.2;

    const ocupaEdificio = edificiosOcupados.some(ed => !(x + 2 < ed.x - ed.w / 2 || x - 2 > ed.x + ed.w / 2 || z + 2 < ed.z - ed.d / 2 || z - 2 > ed.z + ed.d / 2));

    if (!estaEnZonaProhibida(x, z, TAM, TAM) && !ocupaEdificio) {
      const g = new THREE.Group();
      const estilo = treeStyles[Math.floor(Math.random() * treeStyles.length)];
      estilo.crear().forEach(mesh => g.add(mesh));
      g.position.set(x, 0.5, z);
      scene.add(g);
      listaArboles.push(g);
      creados++;
    }
    intentos++;
  }
}

const matRoad = new THREE.MeshStandardMaterial({ color: 0x424242 });

function carretera(w, h, x, z) {
  const r = new THREE.Mesh(new THREE.PlaneGeometry(w, h), matRoad);
  r.rotation.x = -Math.PI / 2;
  r.position.set(x, 1.01, z);
  scene.add(r);
}

carretera(70, 8, 0, 30);
carretera(8, 70, 20, 0);
carretera(15, 8, 25, -10);

const coches = [];
let INTERVALO_SPAWN = 1500;
let DISTANCIA_MINIMA_SPAWN = 10;

let TODAS_LAS_RUTAS = [];
let debugLines = [];
let ultimoSpawnGlobal = 0;
let indiceRutaActual = 0;

const coloresCoches = [0xffd54f, 0xe53935, 0x1e88e5, 0xa52523, 0x4caf50];

function getCarFrontTexture() {
  const canvas = document.createElement("canvas");
  canvas.width = 64; canvas.height = 32;
  const context = canvas.getContext("2d");
  context.fillStyle = "#ffffff";
  context.fillRect(0, 0, 64, 32);
  context.fillStyle = "#666666";
  context.fillRect(8, 8, 48, 24);
  return new THREE.CanvasTexture(canvas);
}

function getCarSideTexture() {
  const canvas = document.createElement("canvas");
  canvas.width = 128; canvas.height = 32;
  const context = canvas.getContext("2d");
  context.fillStyle = "#ffffff";
  context.fillRect(0, 0, 128, 32);
  context.fillStyle = "#666666";
  context.fillRect(10, 8, 38, 24);
  context.fillRect(58, 8, 60, 24);
  return new THREE.CanvasTexture(canvas);
}

function createWheels() {
  const geometry = new THREE.BoxGeometry(0.6, 0.6, 1.65);
  const material = new THREE.MeshLambertMaterial({ color: 0x333333 });
  const wheel = new THREE.Mesh(geometry, material);
  wheel.castShadow = true;
  return wheel;
}

function crearMeshCoche() {
  const car = new THREE.Group();
  const escala = 0.05;

  const backWheel = createWheels();
  backWheel.position.set(-18 * escala, 6 * escala, 0);
  car.add(backWheel);

  const frontWheel = createWheels();
  frontWheel.position.set(18 * escala, 6 * escala, 0);
  car.add(frontWheel);

  const colorCoche = coloresCoches[Math.floor(Math.random() * coloresCoches.length)];

  const main = new THREE.Mesh(
    new THREE.BoxGeometry(60 * escala, 15 * escala, 30 * escala),
    new THREE.MeshLambertMaterial({ color: colorCoche })
  );
  main.position.y = 12 * escala;
  main.castShadow = true;
  car.add(main);

  const carFrontTexture = getCarFrontTexture();
  const carBackTexture = getCarFrontTexture();
  const carRightSideTexture = getCarSideTexture();
  const carLeftSideTexture = getCarSideTexture();
  carLeftSideTexture.center.set(0.5, 0.5);
  carLeftSideTexture.rotation = Math.PI;
  carLeftSideTexture.flipY = false;

  const cabin = new THREE.Mesh(
    new THREE.BoxGeometry(33 * escala, 12 * escala, 24 * escala),
    [
      new THREE.MeshLambertMaterial({ map: carRightSideTexture }),
      new THREE.MeshLambertMaterial({ map: carLeftSideTexture }),
      new THREE.MeshLambertMaterial({ color: 0xffffff }),
      new THREE.MeshLambertMaterial({ color: 0xffffff }),
      new THREE.MeshLambertMaterial({ map: carFrontTexture }),
      new THREE.MeshLambertMaterial({ map: carBackTexture })
    ]
  );
  cabin.position.set(-6 * escala, 25.5 * escala, 0);
  cabin.castShadow = true;
  car.add(cabin);

  return car;
}

function spawnCoche(ruta, numeroRuta) {
  if (ruta.length < 2) return;
  if (coches.length >= MAX_COCHES) return;

  const inicio = ruta[0];
  const ocupado = coches.some(c => c.numeroRuta === numeroRuta && c.mesh.position.distanceTo(inicio) < DISTANCIA_MINIMA_SPAWN);
  if (ocupado) return;

  const mesh = crearMeshCoche();
  mesh.position.copy(inicio);

  const dirInicial = new THREE.Vector3().subVectors(ruta[1], ruta[0]);
  const anguloBase = Math.atan2(dirInicial.x, dirInicial.z);
  mesh.rotation.y = anguloBase - Math.PI / 2;

  scene.add(mesh);

  coches.push({
    mesh,
    segmento: 0,
    t: 0,
    v: THREE.MathUtils.randFloat(0.05, 0.07),
    rotacionActual: mesh.rotation.y,
    ruta: ruta,
    numeroRuta: numeroRuta
  });
}

function animarTrafico() {
  for (let i = coches.length - 1; i >= 0; i--) {
    const c = coches[i];

    let p1 = c.ruta[c.segmento];
    let p2 = c.ruta[c.segmento + 1];

    const distanciaTramo = p1.distanceTo(p2);
    const incrementoAjustado = c.v / (distanciaTramo * 0.1);
    c.t += incrementoAjustado;

    if (c.t >= 1) {
      c.t = 0;
      c.segmento++;
      if (c.segmento >= c.ruta.length - 1) {
        scene.remove(c.mesh);
        coches.splice(i, 1);
        continue;
      }
      p1 = c.ruta[c.segmento];
      p2 = c.ruta[c.segmento + 1];
      c.mesh.position.copy(p1);
    } else {
      c.mesh.position.lerpVectors(p1, p2, c.t);
    }

    const dir = new THREE.Vector3().subVectors(p2, p1);
    const rotacionObjetivo = Math.atan2(dir.x, dir.z) - Math.PI / 2;
    c.rotacionActual = THREE.MathUtils.lerp(c.rotacionActual, rotacionObjetivo, 0.1);
    c.mesh.rotation.y = c.rotacionActual;
  }
}

function crearEtiqueta(posicion, texto) {
  const canvas = document.createElement('canvas');
  const ctx = canvas.getContext('2d');
  canvas.width = 256;
  canvas.height = 64;

  ctx.fillStyle = 'rgba(0, 0, 0, 0.6)';
  ctx.fillRect(0, 0, 256, 64);
  ctx.font = 'Bold 30px Arial';
  ctx.fillStyle = 'white';
  ctx.textAlign = 'center';
  ctx.fillText(texto, 128, 45);

  const tex = new THREE.CanvasTexture(canvas);
  const spriteMat = new THREE.SpriteMaterial({ map: tex });
  const sprite = new THREE.Sprite(spriteMat);

  sprite.position.copy(posicion);
  sprite.position.y += 3;
  sprite.scale.set(6, 1.5, 1);
  scene.add(sprite);
  debugLines.push(sprite);
}

function limpiarDebugRutas() {
  debugLines.forEach(obj => scene.remove(obj));
  debugLines = [];
}

function activarDebugRutas() {
  if (!SHOW_ROUTE_EDITOR) return;
  limpiarDebugRutas();
  TODAS_LAS_RUTAS.forEach((r) => {
    const puntosGeom = new THREE.BufferGeometry().setFromPoints(r.puntos);
    const linea = new THREE.Line(puntosGeom, new THREE.LineBasicMaterial({ color: r.color }));
    scene.add(linea);
    debugLines.push(linea);

    r.puntos.forEach((p, index) => {
      const esferaGeom = new THREE.SphereGeometry(0.8);
      const esferaMat = new THREE.MeshBasicMaterial({ color: r.color });
      const esfera = new THREE.Mesh(esferaGeom, esferaMat);
      esfera.position.copy(p);
      scene.add(esfera);
      debugLines.push(esfera);

      crearEtiqueta(p, `${r.nombre} - P${index}`);
    });
  });
}

function gridToWorld(point) {
  const { cellSize, origin } = rutasData.grid;
  return new THREE.Vector3(
    origin.x + point.x * cellSize,
    1.3,
    origin.z + point.z * cellSize
  );
}

function cargarRutasDesdeData() {
  TODAS_LAS_RUTAS = rutasData.routes.map(route => ({
    id: route.id,
    nombre: route.name,
    color: new THREE.Color(route.color),
    puntos: route.points.map(gridToWorld)
  }));
  ultimoSpawnGlobal = 0;
  indiceRutaActual = 0;
  if (SHOW_ROUTE_EDITOR) {
    activarDebugRutas();
  } else {
    limpiarDebugRutas();
  }
}

async function cargarRutas() {
  try {
    const response = await fetch(ROUTES_URL, { cache: 'no-store' });
    if (!response.ok) {
      throw new Error('No se pudo cargar rutas');
    }
    rutasData = await response.json();
  } catch (error) {
    console.warn('Usando rutas por defecto:', error);
    rutasData = structuredClone(DEFAULT_ROUTES_DATA);
  }
  cargarRutasDesdeData();
  inicializarEditorRutas();
}

function animate(time) {
  requestAnimationFrame(animate);
  animarTrafico();

  if (TODAS_LAS_RUTAS.length > 0 && time - ultimoSpawnGlobal > INTERVALO_SPAWN) {
    const ruta = TODAS_LAS_RUTAS[indiceRutaActual];
    spawnCoche(ruta.puntos, ruta.id);
    ultimoSpawnGlobal = time;
    indiceRutaActual = (indiceRutaActual + 1) % TODAS_LAS_RUTAS.length;
  }

  controls.update();
  renderer.render(scene, camera);
}

actualizarParametrosFisicoquimicos();

document.getElementById('slider-coches').addEventListener('input', (e) => {
  const val = parseInt(e.target.value);
  MAX_COCHES = val;
  document.getElementById('val-coches').innerText = val;

  if (val === 0) {
    INTERVALO_SPAWN = Infinity;
  } else {
    INTERVALO_SPAWN = Math.max(300, 2000 - (val * 45));
  }

  const nuevaDensidad = 0.002 + (MAX_COCHES * 0.0002);
  scene.fog.density = nuevaDensidad;

  const factorCoches = MAX_COCHES / 60;
  const colorLimpio = new THREE.Color(0xFFE082);
  const colorSmog = new THREE.Color(0x888888);
  scene.background.lerpColors(colorLimpio, colorSmog, factorCoches);
  scene.fog.color.copy(scene.background);
  actualizarParametrosFisicoquimicos();
});


document.getElementById('slider-arboles').addEventListener('input', (e) => {
  const val = parseInt(e.target.value);
  document.getElementById('val-arboles').innerText = val;
  actualizarArboles(val);
  actualizarParametrosFisicoquimicos();

});

document.getElementById('slider-edificios').addEventListener('input', (e) => {
  const val = parseInt(e.target.value);
  document.getElementById('val-edificios').innerText = val + "%";
  actualizarEdificios(val);
  actualizarArboles(parseInt(document.getElementById('slider-arboles').value));
  actualizarParametrosFisicoquimicos();
});

const routesPanel = document.getElementById('routes-panel');
const routesCanvas = document.getElementById('routes-canvas');
const routesSelect = document.getElementById('routes-select');
const ctxRoutes = routesCanvas.getContext('2d');
let rutaSeleccionada = null;
let puntoArrastrado = null;

function getCanvasPoint(evt) {
  const rect = routesCanvas.getBoundingClientRect();
  const scaleX = routesCanvas.width / rect.width;
  const scaleY = routesCanvas.height / rect.height;
  return {
    x: (evt.clientX - rect.left) * scaleX,
    y: (evt.clientY - rect.top) * scaleY
  };
}

function gridPointFromCanvas(point) {
  const { cols, rows } = rutasData.grid;
  const cellWidth = routesCanvas.width / cols;
  const cellHeight = routesCanvas.height / rows;
  return {
    x: Math.min(cols - 1, Math.max(0, Math.round(point.x / cellWidth))),
    z: Math.min(rows - 1, Math.max(0, Math.round(point.y / cellHeight)))
  };
}

function canvasPointFromGrid(point) {
  const { cols, rows } = rutasData.grid;
  const cellWidth = routesCanvas.width / cols;
  const cellHeight = routesCanvas.height / rows;
  return {
    x: point.x * cellWidth,
    y: point.z * cellHeight
  };
}

function dibujarGrid() {
  if (!SHOW_ROUTE_EDITOR) return;
  ctxRoutes.clearRect(0, 0, routesCanvas.width, routesCanvas.height);
  const { cols, rows } = rutasData.grid;
  const cellWidth = routesCanvas.width / cols;
  const cellHeight = routesCanvas.height / rows;

  ctxRoutes.strokeStyle = '#e0e0e0';
  ctxRoutes.lineWidth = 1;
  for (let i = 0; i <= cols; i++) {
    ctxRoutes.beginPath();
    ctxRoutes.moveTo(i * cellWidth, 0);
    ctxRoutes.lineTo(i * cellWidth, routesCanvas.height);
    ctxRoutes.stroke();
  }
  for (let j = 0; j <= rows; j++) {
    ctxRoutes.beginPath();
    ctxRoutes.moveTo(0, j * cellHeight);
    ctxRoutes.lineTo(routesCanvas.width, j * cellHeight);
    ctxRoutes.stroke();
  }
}

function dibujarRutas() {
  if (!SHOW_ROUTE_EDITOR) return;
  dibujarGrid();
  rutasData.routes.forEach(route => {
    if (route.points.length < 1) return;
    ctxRoutes.strokeStyle = route.color;
    ctxRoutes.lineWidth = 3;
    ctxRoutes.beginPath();
    route.points.forEach((point, index) => {
      const { x, y } = canvasPointFromGrid(point);
      if (index === 0) {
        ctxRoutes.moveTo(x, y);
      } else {
        ctxRoutes.lineTo(x, y);
      }
    });
    ctxRoutes.stroke();

    route.points.forEach(point => {
      const { x, y } = canvasPointFromGrid(point);
      ctxRoutes.fillStyle = route.color;
      ctxRoutes.beginPath();
      ctxRoutes.arc(x, y, 5, 0, Math.PI * 2);
      ctxRoutes.fill();
    });
  });
}

function actualizarSelectRutas() {
  if (!SHOW_ROUTE_EDITOR) return;
  routesSelect.innerHTML = '';
  rutasData.routes.forEach(route => {
    const option = document.createElement('option');
    option.value = route.id;
    option.textContent = `${route.name} (${route.points.length} pts)`;
    routesSelect.appendChild(option);
  });
  if (!rutaSeleccionada && rutasData.routes.length) {
    rutaSeleccionada = rutasData.routes[0].id;
  }
  routesSelect.value = rutaSeleccionada;
}

function obtenerRutaSeleccionada() {
  return rutasData.routes.find(route => route.id === Number(rutaSeleccionada));
}

function recalcularRutasDesdeEditor() {
  if (!SHOW_ROUTE_EDITOR) return;
  cargarRutasDesdeData();
}

routesSelect.addEventListener('change', (e) => {
  rutaSeleccionada = Number(e.target.value);
});

routesCanvas.addEventListener('mousedown', (evt) => {
  if (!SHOW_ROUTE_EDITOR) return;
  const route = obtenerRutaSeleccionada();
  if (!route) return;
  const canvasPoint = getCanvasPoint(evt);

  const existingIndex = route.points.findIndex(point => {
    const pt = canvasPointFromGrid(point);
    return Math.hypot(pt.x - canvasPoint.x, pt.y - canvasPoint.y) < 8;
  });

  if (evt.shiftKey && existingIndex >= 0) {
    route.points.splice(existingIndex, 1);
    dibujarRutas();
    actualizarSelectRutas();
    recalcularRutasDesdeEditor();
    return;
  }

  if (existingIndex >= 0) {
    puntoArrastrado = existingIndex;
    return;
  }

  route.points.push(gridPointFromCanvas(canvasPoint));
  dibujarRutas();
  actualizarSelectRutas();
  recalcularRutasDesdeEditor();
});

routesCanvas.addEventListener('mousemove', (evt) => {
  if (!SHOW_ROUTE_EDITOR) return;
  if (puntoArrastrado === null) return;
  const route = obtenerRutaSeleccionada();
  if (!route) return;
  const canvasPoint = getCanvasPoint(evt);
  route.points[puntoArrastrado] = gridPointFromCanvas(canvasPoint);
  dibujarRutas();
  actualizarSelectRutas();
  recalcularRutasDesdeEditor();
});

routesCanvas.addEventListener('mouseup', () => {
  if (!SHOW_ROUTE_EDITOR) return;
  puntoArrastrado = null;
});

routesCanvas.addEventListener('mouseleave', () => {
  if (!SHOW_ROUTE_EDITOR) return;
  puntoArrastrado = null;
});

function inicializarEditorRutas() {
  if (!SHOW_ROUTE_EDITOR) return;
  actualizarSelectRutas();
  dibujarRutas();
}

function crearNuevaRuta() {
  if (!SHOW_ROUTE_EDITOR) return;
  const nuevoId = rutasData.routes.length ? Math.max(...rutasData.routes.map(r => r.id)) + 1 : 1;
  const color = `#${Math.floor(Math.random() * 0xffffff).toString(16).padStart(6, '0')}`;
  rutasData.routes.push({
    id: nuevoId,
    name: `Ruta ${nuevoId}`,
    color,
    points: []
  });
  rutaSeleccionada = nuevoId;
  actualizarSelectRutas();
  dibujarRutas();
  recalcularRutasDesdeEditor();
}

function limpiarRutaSeleccionada() {
  if (!SHOW_ROUTE_EDITOR) return;
  const route = obtenerRutaSeleccionada();
  if (!route) return;
  route.points = [];
  dibujarRutas();
  actualizarSelectRutas();
  recalcularRutasDesdeEditor();
}

function descargarJSON() {
  if (!SHOW_ROUTE_EDITOR) return;
  const dataStr = JSON.stringify(rutasData, null, 2);
  const blob = new Blob([dataStr], { type: 'application/json' });
  const url = URL.createObjectURL(blob);
  const link = document.createElement('a');
  link.href = url;
  link.download = 'routes.json';
  link.click();
  URL.revokeObjectURL(url);
}

function cargarJSONDesdeArchivo(file) {
  if (!SHOW_ROUTE_EDITOR) return;
  const reader = new FileReader();
  reader.onload = (event) => {
    try {
      const data = JSON.parse(event.target.result);
      rutasData = data;
      rutaSeleccionada = data.routes?.[0]?.id ?? null;
      cargarRutasDesdeData();
      inicializarEditorRutas();
    } catch (error) {
      console.error('Archivo inválido', error);
      alert('No se pudo cargar el JSON de rutas.');
    }
  };
  reader.readAsText(file);
}


document.getElementById('btn-nueva-ruta').addEventListener('click', crearNuevaRuta);
document.getElementById('btn-limpiar-ruta').addEventListener('click', limpiarRutaSeleccionada);
document.getElementById('btn-descargar').addEventListener('click', descargarJSON);
document.getElementById('input-cargar').addEventListener('change', (e) => {
  if (!SHOW_ROUTE_EDITOR) return;
  if (e.target.files.length) {
    cargarJSONDesdeArchivo(e.target.files[0]);
  }
});

actualizarEdificios(75);
actualizarArboles(80);
actualizarParametrosFisicoquimicos();

if (!SHOW_ROUTE_EDITOR) {
  routesPanel.classList.add('hidden');
}

cargarRutas();

animate(0);

window.addEventListener("resize", () => {
  const a = window.innerWidth / window.innerHeight;
  camera.left = -d * a;
  camera.right = d * a;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
});

</script>
</body>
</html>
