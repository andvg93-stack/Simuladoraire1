<!DOCTYPE html>
<html lang="es">
<head>
<meta charset="UTF-8">
<title>Simulador Ambiental Isométrico</title>
<style>
  body { margin: 0; overflow: hidden; background: #FFE082; font-family: sans-serif; }
  
  /* Estilos para el panel de control */
  #ui-panel {
    position: absolute;
    top: 20px;
    left: 20px;
    background: rgba(255, 255, 255, 0.9);
    padding: 15px;
    border-radius: 10px;
    box-shadow: 0 4px 10px rgba(0,0,0,0.2);
    width: 250px;
    z-index: 100;
  }
  .control-group { margin-bottom: 15px; }
  label { display: block; font-size: 12px; font-weight: bold; margin-bottom: 5px; color: #333; }
  input[type=range] { width: 100%; cursor: pointer; }
  .value-display { float: right; color: #666; }
</style>
</head>
<body>

<div id="ui-panel">
  <h3 style="margin-top:0">Configuración Ambiental</h3>
  
  <div class="control-group">
    <label>Coches (Contaminación) <span id="val-coches" class="value-display">20</span></label>
    <input type="range" id="slider-coches" min="0" max="60" value="20">
  </div>

  <div class="control-group">
    <label>Árboles (Albedo) <span id="val-arboles" class="value-display">80</span></label>
    <input type="range" id="slider-arboles" min="0" max="200" value="80">
  </div>

  <div class="control-group">
    <label>Edificios (Densidad) <span id="val-edificios" class="value-display">75%</span></label>
    <input type="range" id="slider-edificios" min="0" max="100" value="75">
  </div>
</div>

<div id="data-panel" style="position: absolute; top: 20px; right: 20px; background: rgba(0, 0, 0, 0.8); color: #00ff00; padding: 15px; border-radius: 8px; font-family: 'Courier New', monospace; width: 220px; font-size: 13px; z-index: 100; border: 1px solid #444;">
  <h4 style="margin: 0 0 10px 0; color: #fff; text-align: center; border-bottom: 1px solid #444;">ESTACIÓN MONITOREO</h4>
  
  <div>PM2.5: <span id="val-pm25">--</span> µg/m³</div>
  <div>PM10: <span id="val-pm10">--</span> µg/m³</div>
  <div>CO₂: <span id="val-co2">--</span> ppm</div>
  <div>Temp: <span id="val-temp">--</span> °C</div>
  <div>O₃: <span id="val-o3">--</span> ppb</div>
  <div>NOx: <span id="val-nox">--</span> ppb</div>
  <div>COV: <span id="val-cov">--</span> µg/m³</div>
</div>

<script type="importmap">
{
  "imports": {
    "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
    "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
  }
}
</script>

<script type="module">
import * as THREE from 'three';
import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
import { RoundedBoxGeometry } from 'three/addons/geometries/RoundedBoxGeometry.js';

// Cálculos fisicoquímicos

function actualizarParametrosFisicoquimicos() {
  // Capturar valores actuales de los sliders
  const nCoches = parseInt(document.getElementById('slider-coches').value);
  const nArboles = parseInt(document.getElementById('slider-arboles').value);
  const densEdificios = parseInt(document.getElementById('slider-edificios').value);

  // 1. Material Particulado (Aumenta con coches, baja con árboles)
  const pm25 = Math.max(5, (nCoches * 1.2) - (nArboles * 0.05)).toFixed(1);
  const pm10 = Math.max(10, (nCoches * 2.1) - (nArboles * 0.1)).toFixed(1);

  // 2. Dióxido de Carbono (Base 410ppm + impacto coches - mitigación árboles)
  const co2 = Math.floor(410 + (nCoches * 3.5) - (nArboles * 0.4));

  // 3. Temperatura (Efecto isla de calor: edificios y asfalto/coches - sombra árboles)
  const temp = (22 + (densEdificios * 0.08) + (nCoches * 0.05) - (nArboles * 0.02)).toFixed(1);

  // 4. Ozono Troposférico (Precursores NOx + calor)
  const o3 = Math.max(15, (nCoches * 0.8) + (temp * 0.2) - (nArboles * 0.03)).toFixed(1);

  // 5. Óxidos de Nitrógeno (Directamente ligado a combustión de coches)
  const nox = Math.floor(nCoches * 1.8);

  // 6. COV Antropogénicos (Emisiones coches + materiales de construcción/edificios)
  const cov = ( (nCoches * 0.5) + (densEdificios * 0.2) ).toFixed(1);

  // Actualizar la interfaz
  document.getElementById('val-pm25').innerText = pm25;
  document.getElementById('val-pm10').innerText = pm10;
  document.getElementById('val-co2').innerText = co2;
  document.getElementById('val-temp').innerText = temp;
  document.getElementById('val-o3').innerText = o3;
  document.getElementById('val-nox').innerText = nox;
  document.getElementById('val-cov').innerText = cov;
}



/* ================= ESCENA Y CONFIGURACIÓN ================= */
const scene = new THREE.Scene();
scene.background = new THREE.Color("#FFE082");
scene.fog = new THREE.FogExp2(0xefd1b5, 0.002);

const aspect = window.innerWidth / window.innerHeight;
const d = 55;
const camera = new THREE.OrthographicCamera(-d * aspect, d * aspect, d, -d, 0.1, 500);
camera.position.set(65, 65, 65);
camera.lookAt(0, 0, 0);

const renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.shadowMap.enabled = true;
renderer.toneMapping = THREE.ACESFilmicToneMapping;
document.body.appendChild(renderer.domElement);

const controls = new OrbitControls(camera, renderer.domElement);
controls.enableDamping = true;

/* ================= ARRAYS DE GESTIÓN ================= */
let listaEdificios = [];
let listaArboles = [];
let edificiosOcupados = []; // Para colisiones
let MAX_COCHES = 50;

/* ================= MATERIALES Y LUCES ================= */
const buildingPalette = [0x90caf9, 0x64b5f6, 0xa5d6a7, 0xffcc80, 0xce93d8, 0xb0bec5];
const sun = new THREE.DirectionalLight(0xfff4e0, 1.2);
sun.position.set(50, 80, 30);
sun.castShadow = true;
scene.add(sun, new THREE.AmbientLight(0xb3d9ff, 0.5), new THREE.HemisphereLight(0x87ceeb, 0xf0e6d2, 0.4));
// Aumentamos el tamaño de la "caja" para cubrir toda la base de 75x75
const size = 80; 
sun.shadow.camera.left = -size;
sun.shadow.camera.right = size;
sun.shadow.camera.top = size;
sun.shadow.camera.bottom = -size;

// Ajustamos los planos de corte (cerca y lejos) 
// para que no se corten las sombras de edificios altos
sun.shadow.camera.near = 1;
sun.shadow.camera.far = 200;

// IMPORTANTE: Si agrandas mucho la caja, las sombras se verán pixeladas.
// Para compensar, aumentamos la resolución del mapa de sombras:
sun.shadow.mapSize.width = 4096; // Antes 2048
sun.shadow.mapSize.height = 4096;

//coso debug pa saber lo grande de la caja del sol
//const helper = new THREE.CameraHelper(sun.shadow.camera);
//scene.add(helper);


// Base y Agua
const base = new THREE.Mesh(new RoundedBoxGeometry(75, 2, 75, 6, 2), new THREE.MeshStandardMaterial({ color: 0xf5f5f5 }));
base.receiveShadow = true;
scene.add(base);

const agua = new THREE.Mesh(new THREE.BoxGeometry(95, 4, 95), new THREE.MeshStandardMaterial({ color: 0x26c6da, transparent: true, opacity: 0.8 }));
agua.position.y = -3.5;
scene.add(agua);

/* ================= FUNCIONES DE GENERACIÓN ================= */

function crearMaterialFachada(color) {
  const c = document.createElement("canvas");
  c.width = c.height = 128;
  const ctx = c.getContext("2d");
  ctx.fillStyle = `#${color.toString(16)}`;
  ctx.fillRect(0, 0, 128, 128);
  ctx.fillStyle = "rgba(255,255,255,0.35)"
  for (let y = 8; y < 128; y += 18) {
    for (let x = 8; x < 128; x += 18) ctx.fillRect(x, y, 8, 10);
  }
  return new THREE.MeshStandardMaterial({ map: new THREE.CanvasTexture(c) });
}

function limpiarGrupo(lista) {
  lista.forEach(obj => scene.remove(obj));
  return [];
}

const zonasProhibidas = [
  { x: 0, z: 31, w: 70, d: 8 }, // Calle H
  { x: 27, z: -10, w: 15, d: 8 }, // Calle H
  { x: 20, z: 0, w: 8, d: 70 }  // Calle V
  
];


function estaEnZonaProhibida(x, z, w, d) {
  return zonasProhibidas.some(zona => !(x + w / 2 < zona.x - zona.w / 2 || x - w / 2 > zona.x + zona.w / 2 || z + d / 2 < zona.z - zona.d / 2 || z - d / 2 > zona.z + zona.d / 2));
}

/* ================= ACTUALIZACIÓN DINÁMICA ================= */

function actualizarEdificios(densidad) {
  listaEdificios = limpiarGrupo(listaEdificios);
  edificiosOcupados = [];
  
  for (let x = -30; x <= 30; x += 10) {
    for (let z = -30; z <= 30; z += 10) {
      if (Math.random() < densidad / 100) {
        const w = THREE.MathUtils.randInt(4, 7);
        const d = THREE.MathUtils.randInt(4, 7);
        if (estaEnZonaProhibida(x, z, w, d)) continue;

        const h = (Math.hypot(x, z) < 15) ? THREE.MathUtils.randInt(30, 60) : THREE.MathUtils.randInt(10, 25);
        const color = buildingPalette[Math.floor(Math.random() * buildingPalette.length)];
        
        const g = new THREE.Group();
        const cuerpo = new THREE.Mesh(new THREE.BoxGeometry(w, h, d), crearMaterialFachada(color));
        cuerpo.castShadow = cuerpo.receiveShadow = true;
        g.add(cuerpo);
        g.position.set(x, h / 2 + 1, z);
        
        scene.add(g);
        listaEdificios.push(g);
        edificiosOcupados.push({ x, z, w: w + 2, d: d + 2 });
      }
    }
  }
}

function actualizarArboles(cantidad) {
  listaArboles = limpiarGrupo(listaArboles);
  let creados = 0;
  let intentos = 0;

  while (creados < cantidad && intentos < 400) {
    const x = THREE.MathUtils.randFloat(-32, 32);
    const z = THREE.MathUtils.randFloat(-32, 32);
    const TAM = 3;

    const ocupaEdificio = edificiosOcupados.some(ed => !(x + 2 < ed.x - ed.w / 2 || x - 2 > ed.x + ed.w / 2 || z + 2 < ed.z - ed.d / 2 || z - 2 > ed.z + ed.d / 2));

    if (!estaEnZonaProhibida(x, z, TAM, TAM) && !ocupaEdificio) {
      const g = new THREE.Group();
      const copa = new THREE.Mesh(new THREE.ConeGeometry(1.5, 3, 8), new THREE.MeshStandardMaterial({ color: 0x43a047 }));
      copa.position.y = 3; copa.castShadow = true;
      const tronco = new THREE.Mesh(new THREE.CylinderGeometry(0.2, 0.3, 2), new THREE.MeshStandardMaterial({ color: 0x6d4c41 }));
      tronco.position.y = 1;
      g.add(tronco, copa);
      g.position.set(x, 0.5, z);
      scene.add(g);
      listaArboles.push(g);
      creados++;
    }
    intentos++;
  }
}

/* ================= CARRETERAS ================= */
const matRoad = new THREE.MeshStandardMaterial({ color: 0x424242 });

function carretera(w, h, x, z) {
  const r = new THREE.Mesh(new THREE.PlaneGeometry(w, h), matRoad);
  r.rotation.x = -Math.PI / 2;
  r.position.set(x, 1.01, z);
  scene.add(r);
}

carretera(70, 8, 0, 31);
carretera(8, 70, 20, 0);
carretera(15, 8, 27, -10);


/* ================= TRÁFICO  ================= */

const coches = [];
let INTERVALO_SPAWN = 1500; // 
let DISTANCIA_MINIMA_SPAWN = 10; 


const TODAS_LAS_RUTAS = [
  {
    id: 1,
    puntos: [
      new THREE.Vector3(-35, 1.3, 30),
      new THREE.Vector3(18, 1.3, 30),
      new THREE.Vector3(18, 1.3, -35)
    ]
  },
  {
    id: 2,
    puntos: [
      new THREE.Vector3(33, 1.3, 33),
      new THREE.Vector3(-35, 1.3, 33)
    ]
  },
  {
    id: 3,
    puntos: [
  new THREE.Vector3(22, 1.3, -35),
  new THREE.Vector3(22, 1.3, 33),
  new THREE.Vector3(-35, 1.3, 33),
    ]
  },
  {
    id: 4,
    puntos: [
      new THREE.Vector3(33, 1.3, 30),
      new THREE.Vector3(22, 1.3, 30),
      new THREE.Vector3(22, 1.3, -12),

    ]
  }

];


let ultimoSpawn1 = 0;
let ultimoSpawn2 = 0;

/* ================= GEOMETRÍA DETALLADA DE COCHES ================= */

const coloresCoches = [0xffd54f, 0xe53935, 0x1e88e5, 0xa52523, 0x4caf50];

function getCarFrontTexture() {
  const canvas = document.createElement("canvas");
  canvas.width = 64; canvas.height = 32;
  const context = canvas.getContext("2d");
  context.fillStyle = "#ffffff";
  context.fillRect(0, 0, 64, 32);
  context.fillStyle = "#666666"; // Color del cristal
  context.fillRect(8, 8, 48, 24);
  return new THREE.CanvasTexture(canvas);
}

function getCarSideTexture() {
  const canvas = document.createElement("canvas");
  canvas.width = 128; canvas.height = 32;
  const context = canvas.getContext("2d");
  context.fillStyle = "#ffffff";
  context.fillRect(0, 0, 128, 32);
  context.fillStyle = "#666666";
  context.fillRect(10, 8, 38, 24);
  context.fillRect(58, 8, 60, 24);
  return new THREE.CanvasTexture(canvas);
}

function createWheels() {
  const geometry = new THREE.BoxGeometry(0.6, 0.6, 1.65);
  const material = new THREE.MeshLambertMaterial({ color: 0x333333 });
  const wheel = new THREE.Mesh(geometry, material);
  wheel.castShadow = true;
  return wheel;
}

function crearMeshCoche() {
  const car = new THREE.Group();
  const escala = 0.05;
  
  // Ruedas
  const backWheel = createWheels();
  backWheel.position.set(-18 * escala, 6 * escala, 0);
  car.add(backWheel);
  
  const frontWheel = createWheels();
  frontWheel.position.set(18 * escala, 6 * escala, 0);
  car.add(frontWheel);
  
  // Color aleatorio
  const colorCoche = coloresCoches[Math.floor(Math.random() * coloresCoches.length)];
  
  // Cuerpo principal
  const main = new THREE.Mesh(
    new THREE.BoxGeometry(60 * escala, 15 * escala, 30 * escala),
    new THREE.MeshLambertMaterial({ color: colorCoche })
  );
  main.position.y = 12 * escala;
  main.castShadow = true;
  car.add(main);
  
  // Cabina con ventanas
  const carFrontTexture = getCarFrontTexture();
  const carBackTexture = getCarFrontTexture();
  const carRightSideTexture = getCarSideTexture();
  const carLeftSideTexture = getCarSideTexture();
  carLeftSideTexture.center.set(0.5, 0.5);
  carLeftSideTexture.rotation = Math.PI;
  carLeftSideTexture.flipY = false;

  const cabin = new THREE.Mesh(
    new THREE.BoxGeometry(33 * escala, 12 * escala, 24 * escala),
    [
      new THREE.MeshLambertMaterial({ map: carRightSideTexture }), // +X
      new THREE.MeshLambertMaterial({ map: carLeftSideTexture }),  // -X
      new THREE.MeshLambertMaterial({ color: 0xffffff }),          // +Y
      new THREE.MeshLambertMaterial({ color: 0xffffff }),          // -Y
      new THREE.MeshLambertMaterial({ map: carFrontTexture }),     // +Z
      new THREE.MeshLambertMaterial({ map: carBackTexture })       // -Z
    ]
  );
  cabin.position.set(-6 * escala, 25.5 * escala, 0);
  cabin.castShadow = true;
  car.add(cabin);
  
  return car; // Retornamos el grupo
}



function spawnCoche(ruta, numeroRuta) {
  if (coches.length >= MAX_COCHES) return;

  const inicio = ruta[0];
  const ocupado = coches.some(c => c.mesh.position.distanceTo(inicio) < 8);
  if (ocupado) return;

  // --- AQUÍ USAMOS LA NUEVA GEOMETRÍA ---
  const mesh = crearMeshCoche(); 
  mesh.position.copy(inicio);
  
  const dirInicial = new THREE.Vector3().subVectors(ruta[1], ruta[0]);
  const anguloBase = Math.atan2(dirInicial.x, dirInicial.z);
  mesh.rotation.y = anguloBase - Math.PI / 2;

  scene.add(mesh); // Añadir el grupo completo a la escena

  coches.push({
    mesh,
    segmento: 0,
    t: 0,
    v: THREE.MathUtils.randFloat(0.05, 0.07),
    rotacionActual: mesh.rotation.y,
    ruta: ruta,
    numeroRuta: numeroRuta
  });
}

function animarTrafico() {
  for (let i = coches.length - 1; i >= 0; i--) {
    const c = coches[i];
    
    const p1 = c.ruta[c.segmento];
    const p2 = c.ruta[c.segmento + 1];
    
    // 1. Calculamos la distancia real entre los dos puntos actuales
    const distanciaTramo = p1.distanceTo(p2);
    
    // 2. Ajustamos el incremento de 't' para que sea independiente de la distancia
    // Dividimos su velocidad base entre la distancia del tramo
    const incrementoAjustado = c.v / (distanciaTramo * 0.1); 
    c.t += incrementoAjustado;

    if (c.t >= 1) {
      c.t = 0;
      c.segmento++;
      if (c.segmento >= c.ruta.length - 1) {
        scene.remove(c.mesh);
        coches.splice(i, 1);
        continue;
      }
    }

    // Movimiento suave
    c.mesh.position.lerpVectors(p1, p2, c.t);

    // Rotación suave al girar esquinas
    const dir = new THREE.Vector3().subVectors(p2, p1);
    const rotacionObjetivo = Math.atan2(dir.x, dir.z) - Math.PI / 2;
    c.rotacionActual = THREE.MathUtils.lerp(c.rotacionActual, rotacionObjetivo, 0.1);
    c.mesh.rotation.y = c.rotacionActual;
  }
}

/* ================= LOOP DE ANIMACIÓN Y EVENTOS ================= */

// Crea un array para llevar el control del tiempo de cada ruta
const ultimosSpawns = TODAS_LAS_RUTAS.map(() => 0);

function animate(time) {
  requestAnimationFrame(animate);
  animarTrafico();

  // Recorrer todas las rutas dinámicamente
  TODAS_LAS_RUTAS.forEach((ruta, index) => {
    if (time - ultimosSpawns[index] > INTERVALO_SPAWN) {
      // Intentar spawnear un coche en esta ruta
      spawnCoche(ruta.puntos, ruta.id);
      ultimosSpawns[index] = time;
    }
  });

  controls.update();
  renderer.render(scene, camera);
}

/* ================= LISTENERS DE LOS SLIDERS ================= */

actualizarParametrosFisicoquimicos();

document.getElementById('slider-coches').addEventListener('input', (e) => {
  const val = parseInt(e.target.value);
  MAX_COCHES = val;
  document.getElementById('val-coches').innerText = val;

  // --- NUEVA LÓGICA DE INTERVALO DINÁMICO ---
  if (val === 0) {
    INTERVALO_SPAWN = Infinity; // Si es 0, no spawnean coches
  } else {
    // A más coches, menos tiempo de espera. 
    // Fórmula: 3000ms de base menos un factor proporcional al slider.
    // Con val=60, el intervalo será aprox 300ms.
    INTERVALO_SPAWN = Math.max(300, 2000 - (val * 45));
  }

  // --- EFECTO DE SMOG ---
  // Calculamos una densidad entre 0.002 (limpio) y 0.02 (muy contaminado)
  const nuevaDensidad = 0.002 + (MAX_COCHES * 0.0002);
  scene.fog.density = nuevaDensidad;

  // Opcional: Oscurecer el fondo para simular polución
  // Interpolamos entre el color original #FFE082 y un gris #888888
  const factorCoches = MAX_COCHES / 60; // 60 es el máximo del slider
  const colorLimpio = new THREE.Color(0xFFE082);
  const colorSmog = new THREE.Color(0x888888);
  scene.background.lerpColors(colorLimpio, colorSmog, factorCoches);
  scene.fog.color.copy(scene.background); // Que la niebla combine con el cielo
  actualizarParametrosFisicoquimicos();

});


document.getElementById('slider-arboles').addEventListener('input', (e) => {
  const val = parseInt(e.target.value);
  document.getElementById('val-arboles').innerText = val;
  actualizarArboles(val);
  actualizarParametrosFisicoquimicos();

});

document.getElementById('slider-edificios').addEventListener('input', (e) => {
  const val = parseInt(e.target.value);
  document.getElementById('val-edificios').innerText = val + "%";
  actualizarEdificios(val);
  actualizarArboles(parseInt(document.getElementById('slider-arboles').value)); // Re-ubicar árboles
  actualizarParametrosFisicoquimicos();
});

/* ================= DEBUG RUTAS ================= */


function activarDebugRutas() {
  TODAS_LAS_RUTAS.forEach((r) => {

    // 1. Dibujar la línea de la ruta
    const puntosGeom = new THREE.BufferGeometry().setFromPoints(r.puntos);
	const linea = new THREE.Line(puntosGeom, new THREE.LineBasicMaterial({ color: Math.random() * 0xffffff }));
    scene.add(linea);

    // 2. Dibujar esferas en los nodos (puntos)
    r.puntos.forEach((p, index) => {
      const esferaGeom = new THREE.SphereGeometry(0.8);
      const esferaMat = new THREE.MeshBasicMaterial({ color: r.color });
      const esfera = new THREE.Mesh(esferaGeom, esferaMat);
      esfera.position.copy(p);
      scene.add(esfera);

      // Crear etiqueta simple usando un Canvas (opcional pero muy útil)
      crearEtiqueta(p, `${r.nombre} - P${index}`);
    });
  });
}

// Función auxiliar para etiquetas en el espacio 3D
function crearEtiqueta(posicion, texto) {
  const canvas = document.createElement('canvas');
  const ctx = canvas.getContext('2d');
  canvas.width = 256;
  canvas.height = 64;
  
  ctx.fillStyle = 'rgba(0, 0, 0, 0.6)';
  ctx.fillRect(0, 0, 256, 64);
  ctx.font = 'Bold 30px Arial';
  ctx.fillStyle = 'white';
  ctx.textAlign = 'center';
  ctx.fillText(texto, 128, 45);

  const tex = new THREE.CanvasTexture(canvas);
  const spriteMat = new THREE.SpriteMaterial({ map: tex });
  const sprite = new THREE.Sprite(spriteMat);
  
  sprite.position.copy(posicion);
  sprite.position.y += 3; // Elevar la etiqueta sobre el punto
  sprite.scale.set(6, 1.5, 1);
  scene.add(sprite);
}


// === INICIALIZACIÓN INICIAL ===
// Ejecutamos las funciones una vez para que la escena no empiece vacía
actualizarEdificios(75);
actualizarArboles(80);
actualizarParametrosFisicoquimicos(); // Para que el panel de datos no esté en "--"



activarDebugRutas(); // <--- Activa la visualización de rutas aquí

// Arrancamos el loop (pasándole 0 como tiempo inicial)
animate(0);

/* ================= RESPONSIVE ================= */
window.addEventListener("resize", () => {
  const a = window.innerWidth / window.innerHeight;
  camera.left = -d * a;
  camera.right = d * a;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
});

</script>
</body>
</html>